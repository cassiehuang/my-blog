[{"categories":["articles"],"content":"https://www.cnblogs.com/Eleven-Liu/p/10336181.html\nCAS  CAS是企业级的单点登陆解决方案 大概流程是 （1）浏览器向www发起请求，无ST （2）www返回一个重定向到cas的请求，带上返回地址 （3）浏览器向cas发起请求 （4）cas检查TGC，第一次访问，不带TGC，则返回登陆页面 （5）浏览器填写好登陆信息后发送给cas （6）cas验证登陆信息，在cookie中写入TGC，下次浏览器访问cas会带上这个TGC，写入重定向，并将ST写入www地址链接 （7）浏览器重定向到www网站，携带ST （8）www根据ST去cas验证登陆是否有效 （9）cas根据ST验证，通过后，告诉www该ST有效，www在session中记录登录状态 （10）www返回浏览器资源 （11）浏览器第二次访问www （12）www从session中知道已经登陆，直接返回资源 （13）浏览器访问mail （14）mail返回一个重定向请求，重定向到cas （15）浏览器访问cas，会带上TGC （16）cas验证TGC，返回ST（token），并让浏览器重定向到mail （17）重定向到mail （18）mail根据ST去cas验证是否有效 （19）cas验证有效后，返回mail，mail通过后在session中设置登录状态 （20）返回浏览器资源  ","description":"","tags":null,"title":"Cas单点登录","uri":"/articles/cas/"},{"categories":["articles"],"content":"文件结构 ---config -----plugin.js 引入插件 -----config.default.js 默认配置文件，所有环境都会加载这个文件，一般作为开发环境的默认配置文件配置 -----config.prod.js 生产环境配置（prod 是env，指） ---app -----router api和controller的映射 -----controller 解析用户输入，处理后返回相应结构，利用service和数据库交互 -----service 进行复杂业务逻辑处理 -----model 数据库表映射 -----middleware 中间件，注册在配置文件config,或者在框架和插件中使用 -----router.js （必须）框架统一以此作为所有路由入口 ---run egg框架启动时会把合并后的最终配置dump到agent_config中 -----agent_config_meta.json -----agent_config.json ---package.json 依赖和script命令 ---app.js 统一的入口文件，进行启动过程自定义，可以利用框架提供的生命周期函数 ---pkg-build.js 是执行build-win和build-linux时会执行，配置在package.json内的bin字段下 ---preload.js 执行start命令时的配置文件，主要是负责读取配置环境env 插件 egg-view-nunjucks 渲染html的模版插件\n 写入plugin config.default.js 中配置  1 2 3 4 5  config.view = { mapping: { '.html': 'nunjucks' } }   egg-jwt 生成token的插件 egg管理token的插件，可以通过config里的match来匹配需要验证的token的路由 egg-sequelize 辅助我们将定义好的model对象加载到app和cxt上\nmiddleware 中间件写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  module.exports = (options, app) = { return async function auth(ctx, next) { cxt.set('Access-Control-Allow-Credentials', 'true') const token = ctx.header['token'] const result = awiat ctx.service.auth.vertify(token) if (result) { await next() } else { ctx.body = { result: '99', message: '您的请求不合法' } } } } module.exports = () = { return async function(ctx, next) { const startTime = Date.now() await next(); const endTime = Date.now() reportTime(endTime - startTime) } } // 在app.js中加入 module.exports = app = { app.config.coreMiddleware.unshif('report') }   router 1 2 3 4 5  module.export = app = { const { router, controller } = app; router.redirect('/', '/public/index.html', 302) router.get('/user/:id', controller.user.info) }   controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  const controller = require('egg').Controller; class UserController extends Controller { async login() { const ctx = this.ctx; ctx.validate(user_rules.loginRule); const { account, email, password, customerCode, yzm } = ctx.request.body; let body = { result: 0, message: '操作成功' } let { login_code } = ctx.session if (login_code) { if (yzm !== login_code) { body.result = 1; body.message = '验证码错误'， ctx.body = body; return } } else { login_code = ctx.cookies.get('login_code'); if (login_code \u0026\u0026 yzm !== login_code) { body.result = 1; body.message = '验证码错误‘ ctx.body = body; return; } else if (!login_code) { body.result = 1; body.message = '您的浏览器禁用了cookie' cxt.body = body; return; } } } }   service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const Service = require('egg').Service class UserService extends Service { async find(field) { const w = { $or: [{ uid: fields.uid }, { email: fields.email }] } return await this.ctx.model.User.findOrcreat({ where: w, defaults: fields }) } }   model schedule 定时任务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const Subscription = require('egg').Subscription class UpdateCache extends Subscription { static get schedule() { return { interval: '1m', type: 'all' } } async subscribe() { const res = await this.cxt.curl('http://www.api.com/cache', { dataType: 'json' }) this.ctx.app.cache = res.data; } } module.exports = UpdateCache   注意事项 1.开发环境没有注册auth的中间件，生产环境注册了ac 2.MVC整个结构通过router.j串联起来，router.js文件位置固定app/router.js 3.应用层中间件：app.config.appMiddleware 框架默认层中间件:app.config.coreMiddleware 4.所有controller必须放在app/controller目录下，可多级目录 5.ctx.body 实际上是ctx.response.body的简写\n","description":"","tags":null,"title":"egg实战-教学服务","uri":"/articles/egg%E5%AE%9E%E6%88%98-%E6%95%99%E5%AD%A6%E6%9C%8D%E5%8A%A1/"},{"categories":["articles"],"content":"systemjs 运行于浏览器端的模块加载器，将我们整个应用的所需要的js文件，都以imports的形式引入进来 使用方法一： System.import('./test.js'); 使用方法二：\n 写一个配置文件，给每个资源定义一个key { “imports”: { “vue”: ‘./public/vue.js’, “single-spa”: ‘./public/single-spa.js’ } } 引入配置文件   引入文件 System.import(key)  single-spa实践 结构目录设计 —common —projects —root_html_file —–index.html 引入index.js, systemjs，single-spa, —–index.js —–registry ——–public_dependents.json ——–singleSpa_project.json\nindex.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  (async function() { var System_imports = [ System.import('./single-spa.js'), System.import('./frame.js') ]; Promise.all(System_imports).then((modules) =\u003e { var SingleSpa = modules[0]; var Frame = modules[1]; SingleSpa.registerApplication( 'frame', Frame, () =\u003e true ) SingleSpa.start(); window.addEventListener('INIT_FRAME', function() { const arr = Object.keys(SINGLE_SPA_PROJECTS); arr.forEach((project) =\u003e { if (project !== 'frame') { SingleSpa.registerApplication( project, () =\u003e System.import(SINGLE_SPA_PROJECTS[project]), location =\u003e location.pathname.indexOf('/' + project) === 0 ) } }) }) }) })()   ","description":"","tags":null,"title":"Single Spa","uri":"/articles/single-spa/"},{"categories":["articles"],"content":"文件目录规范 1、/src/pages文件夹内只能存放真正的一级导航页面，如果是页面分为多个组件模块，在pages内建同名文件夹下存放组件 2、常量采用全大写的方式命名，且存放在constant/index.js 文件内统一进行管理 3、接口文件统一在api里进行管理 4、图片、文件名不能用中文命名 5、较大的图片，如背景图等放在static文件夹下（图片会单独打包，利于缓存命中） 6、较小的图片，如各种图标，放在asset文件夹下（图片会以base64的方式打包进文件，减少请求次数） 7、一个vue文件代码行数尽量不要超过500行，超过的500行的考虑拆分为组件 css规范 1、html内类名以-连接，如“container-wrap”，补充一个id和class命名规则（BEM（Block， Element， Modifier）命名规范）： •\tBlock：独立有意义的实体，eg：header、container、menu、checkbox、footer等在页面布局时，划分单独模块 •\tElement：元素，是Block下的子元素，其没有独立的意义，属于Block的一部分，eg：menu-item，list-item，header-title等 •\tModifier：Block或者Element上的标志标识，用来改变外观、状态、行为、标记等，eg：disabled、checked、color yellow，size big，highlighted等 2、类选择器比元素选择器更好，尽量减少元素选择器的使用 3、为组件样式添加scope作用域，如果不能使用scope作用域的样式，需要添加具有组件内唯一性的类名，避免对其他组件造成影响 4、公用样式放在common.less文件内 js规范 1、vue组件命名以PascalCase的方式命名（ufp框架内用cameCase方式命名） 2、组件不能和html5的标签重复，如“Footer”、“Header”不能存在 3、使用组件时，组件全小写以-的方式连接，如“” 4、文件的引入不使用“import { parseTime } from ‘../../utils/index’”这种方式，采用“import { parseTime } from ‘@/utils/index’”,@路径指向src路径，采用前者经常会导致路径错误，且不利于文件移动 5、js文件内变量采用cameCase命名法，如“resultList” 6、使用v-for指令要设置key，尽量不用index作为key值 7、避免v-if和v-for同时作用于同一个元素上 举例：\u003cli v-for=\"(value, key) in arr\" v-if=“value.show”\u003e 错误 \u003cli v-for=\"(value, key) in filterArr\"\u003e 正确 8、优先使用vuex管理全局状态，而不是通过this.$root或者全局事件总线 9、指令缩写：（用：表示v-bind，用@表示v-on） 10、组件模板（template）内应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或者方法 11、不同逻辑、不同业务、不同语义之间打代码插入一个空行分隔来提升可读性 12、不使用匿名函数 13、不使用var，使用let、const 14、数组循环时需要分清forEach、map、filter的不同使用场景 15、函数的功能要尽可能单一 其他 1、因为目前使用的是git进行版本管理，任何时候的代码都能跟踪找回，所以对于无用代码需要及时删除，比如一些调试的console语句、无用的弃用功能代码 工具 1、使用prettier、eslint格式化代码，处理换行、缩进、分号、单引号、双引号、空格等问题，保存文件时自动保持一致，规范采用eslint:recommend，具体项可参考https://eslint.bootcss.com/docs/rules (工具使用：基于vscode建立vue项目前端规范)\n","description":"","tags":null,"title":"前端开发规范梳理","uri":"/articles/frontend/"},{"categories":["articles"],"content":"前端微服务出现的趋势 而在前端微服务化上，人们更想要的结果是聚合，尤其是那些 To B（to Bussiness）的应用。\n在这两三年里，移动应用出现了一种趋势，用户不想装那么多应用了。而往往一家大的商业公司，会提供一系列的应用。这些应用也从某种程度上，反应了这家公司的组织架构。然而，在用户的眼里他们就是一家公司，他们就只应该有一个产品。相似的，这种趋势也在桌面 Web 出现。聚合成为了一个技术趋势，体现在前端的聚合就是微服务化架构\n路由分发式微前端  主要是通过路由将不同业务分发到不同的、独立的前端应用上 最易采用的‘微前端’方案 例如，基于nginx，通过路由，分发的到不同的服务器  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  http { server { listen: 80; server_name: www.phodal.com; location /api/ { proxy_pass http://172.31.23.13:8080/api  } location /web/admin/ { proxy_pass http://172.31.23.25/web/admin  } location /web/notify/ { proxy_pass http://172.31.23.22/web/notify  } } }   iframe创建容器 1.html内联框架元素表示嵌套的正在浏览的上下午呢，能有效的将另一个html页面嵌入当前页面 2. 采用iframe需要两点要求：无seo支持，拥有相应的应用管理机制\n自制框架兼容应用  在页面合适的地方引入或创建DOM 用户操作时，加载对应的应用，并能卸载应用 （Single-SPA 已经拥有了大部分框架的启动和卸载处理）  组合式集成：将应用微件化  组合式集成，即通过软件工程的方式在构建前、构建时、构建后等步骤中，对应用进行进一步拆分，并重新组合 （独立仓储，独立开发，构建时整体打包，合并应用）  纯Web Components技术构建 结合Web Components构建 微服务的难点  微服务的难点是需要考虑多个模块之间如何调用的问题，以及鉴权、日志、甚至加入网关层 微前端应用在运行时是一个整体，需要聚合，甚至还需要交互、通信  ","description":"","tags":null,"title":"微服务","uri":"/articles/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"categories":["articles"],"content":"配置vue history模式支持 server { try_files $uri $uri/ /erp-farm-admin/index.html; }\n配置反向代理 loaction ^~ /api/ { proxy_pass http://127.0.0.1:8081/ }\nworker_processes 1; events {worker_connections 1024;} http {include mime.types;default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80;server_name localhost; #gzip服务开启，对大于100k的文件进行gzip压缩，提高前端资源的响应速度 gzip on; gzip_static on; gzip_min_length 100; gzip_comp_level 6; gzip_types application/javascript text/css text/xml; gzip_disable \"MSIE [1-6]\\.\"; gzip_vary on; gzip_buffers 32 4K; #上传文件大小限制 client_max_body_size 100M; #charset koi8-r; #access_log logs/host.access.log main; location / { #静态资源的根路径 root /usr/share/nginx/html/cbkc-web/;index index.html index.htm; #支持vue history路由模式 try_files $uri $uri/ /index.html; #html文件不缓存，可以解决每次上线后，由于浏览器缓存造成的错误 if ($request_filename ~* .*\\.(?:htm|html)$) { add_header Cache-Control \"private, no-store, no-cache, must-revalidate, proxy-revalidate\"; } #js和css文件设置过期时间 if ($request_filename ~* .*\\.(?:js|css)$) {expires 7d;} #图片、视频等文件设置过期时间 if ($request_filename ~* .*\\.(?:jpg|ipeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$) {expires 7d;}} location /manager/ {alias /usr/share/nginx/html/cbkc-web-admin/;index index.html index.htm;} #反向代理，解决跨域问题 location ^~ /api/ { #后台开启了请求来源检测 proxy_set_header host $host; proxy_pass http://112.7.35.26:8082/; } ","description":"","tags":null,"title":"安装和配置nginx服务器","uri":"/articles/nginx/"},{"categories":["articles"],"content":"初识Puppeteer 2017年，Chrome开发团队发布了一个node.js的包，用来模拟Chrome浏览器的运行，这个包就是Puppeteer。和同类产品Phantomjs、Selenium相比，Puppeteer作为“自家的”孩子，具有天然的优势。Puppeteer默认以无头（无界面）的方式运行，但是也可以配置运行为有界面的Chrome。使用puppeteer可以自动化在浏览器中完成手动执行的大多数事情，比如： 生成页面的屏幕截图和PDF。 抓取SPA并生成服务端渲染SSR。 自动化提交表单、UI测试、键盘输入等。 捕捉网站的时间线跟踪，以帮助诊断性能问题。 （一）爬虫 以前尝试用过python写爬虫，但是因为对语言不熟悉，对它的库也不熟悉，所以写起来非常耗时，需要学习很多新的知识。然后我尝试用最熟悉的js语言来写，果然发现了新的世界，一切变得轻松起来。 下面是我爬取SonarQube的项目数据的代码，算是较为复杂的场景。\n  使用launch创建一个无头浏览器\n  使用newPage创建一个新窗口\n  page.goto进入登录页面\n  网站使用的是react渲染页面，所有进入页面时，页面元素还没有渲染，如果直接获取DOM会导致获取不到，这里使用waitForSelector来等待DOM渲染完成\n  使用page.type给输入框输入用户名和密码\n  模拟用户点击登录操作\n  page.goto进入目标页面。目前很多网站使用前端渲染，导致直接输入地址无法获取到最终数据，需要模拟用户输入，等待接口响应，重新渲染之后才能开始爬取数据 使用waitForSelector等待搜索框加载完成 使用page.evaluate()进入浏览器的上下文环境，在这里可以直接使用DOM操作语句等，这里使用document.querySelector获取到搜索框并清空搜索框文字 page.type给搜索框输入关键字 waitForResponse等待接口响应，因为响应的内容不是纯粹可读取数据，无法直接解析，所以等到页面渲染后来解析页面元素。响应内容如下图。\n  页面是分页加载的，所以如果有下一页，还需要点击下一页\n  继续等待接口响应\n  解析页面元素，page.$$eval()类似于document.querySelectorAll，page.$eval()类似于document.querySelector()\n  操作结束后browser.close()关闭浏览器\n  使用xlsx将爬取的数据导出为excel\n  将excel文件保存到本地\n  const puppeteer = require('puppeteer-core'); const findChrome = require('carlo/lib/find_chrome'); const XLSX = require('xlsx'); // 搜索关键词 const keywords = ['k12', 'ippp']; const data = []; (async () =\u003e { let findChromePath = await findChrome({}) let executablePath = findChromePath.executablePath const browser = await puppeteer.launch({ executablePath, headless: true, }) const page = await browser.newPage(); page.on('console', (msg) =\u003e console.log(msg.text())) // 登录 await page.goto('http://22.4.15.55:9000/sessions/new') await page.waitForSelector('#login') await page.type('input[name=\"login\"]', 'chenyu') await page.type('input[name=\"password\"]', 'chenyu') await page.click('#login_form .text-right button') try { await page.goto('http://22.4.15.55:9000/projects/favorite') } catch(err) { console.log(err) } for (let keyword of keywords) { await (async (keyword) =\u003e { await page.waitForSelector('.boxed-group') await page.waitForSelector('.projects-topbar-item-search input[type=\"search\"]') await page.evaluate(() =\u003e { console.dir(document.querySelector('.projects-topbar-item-search input')) document.querySelector('.projects-topbar-item-search input').value = '' }) await page.type('.projects-topbar-item-search input[type=\"search\"]', keyword) await page.waitForResponse('http://22.4.15.55:9000/api/organizations/search?organizations=default-organization') await page.waitFor(1000) await page.waitForSelector('.boxed-group') try { await page.waitForSelector('.spacer-top.note.text-center .spacer-left') await page.click('.spacer-top.note.text-center .spacer-left') await page.waitForResponse('http://22.4.15.55:9000/api/organizations/search?organizations=default-organization') await page.waitFor(1000) } catch(err) { console.log(err) } const arr = await page.$$eval('.projects-list .boxed-group', (els) =\u003e { const result = els.map((el) =\u003e { const obj = {} obj.name = el.querySelector('.project-card-name a').innerText; el.querySelectorAll('.project-card-measure-number .spacer-right').forEach((item, key) =\u003e { switch (key) { case 0: obj.bug = item.innerText; break; case 1: obj['漏洞'] = item.innerText; break; case 2: obj['坏味道'] = item.innerText; break; case 3: obj['覆盖率'] = item.nextElementSibling.innerText; break; case 4: obj['重复率'] = item.nextElementSibling.innerText; break; default: break; } }) el.querySelectorAll('.project-card-measure-number .rating').forEach((item, key) =\u003e { switch (key) { case 0: obj['bug级别'] = item.innerText; break; case 1: obj['漏洞级别'] = item.innerText; break; case 2: obj['坏味道级别'] = item.innerText; break; default: break; } }) return obj }) return result }) data.push(arr) })(keyword) } await browser.close() })().then(() =\u003e { data.forEach((val, index) =\u003e { exportFun(val, keywords[index]) }) }) const exportFun = function (data, name) { const ws = XLSX.utils.json_to_sheet(data) const wb = XLSX.utils.book_new() wb.Sheets['Sheet1'] = XLSX.utils.book_append_sheet(wb, ws, '数据详情') console.log(name) XLSX.writeFile(wb, `sonar_${name}.xlsx`) } （二）自动化测试 自动化测试的重要性不言而喻，每次开发一个新功能或者对现有功能进行优化，总是担心测试无法覆盖全局，要是全部做回归测试，又非常耗时。在实践 DevOps 流程的过程中，我们意识到，每次提交一小段代码、频繁提交通常可以极大地减少 bug 的数量，使我们的产品能够更好地响应用户和市场需求，同时为我们自己创造一个良好的工作环境。在实现频繁发布的过程中，手动测试常常是一个很大的难点。因为不管出于什么原因，组织需要为每个版本运行一遍完整的手工测试。这使得新功能的测试会有滞后，以便 QA 可以一次处理尽可能多的之前版本出现的已知 Bug。如果我们忽略了这一点，一旦如果出现 Bug，那么很难跟踪几十次提交中哪一次引入了 Bug。这样通常会阻塞开发几天，只为了在一个版本上重现这个 bug。我们发明了一些复杂的过程，比如一个星期的代码冻结，以创建一个 “稳定的测试环境”，但实际上，它往往并不稳定。 借用Puppeteer，我们可以代码模拟用户行为，将测试用例的操作步骤“录制”下来，之后每次点击运行就可以自动测试完成，并生成测试报告。目前比较成熟的方案就包括cucumber+puppeteer的自动化测试方案。下面是一个简单的demo。 编写测试用例（剧本），按照一定的格式（每句话以Given、When、Then、And、But开头），也支持中文（假如、并且、那么等）\n# language: zh-CN 功能: 网站测试 主要功能点： 1.计数器功能 2.动态显示 场景: 计数器功能测试 假如打开网页，页面应该有标题显示 并且初始数量应该为0 那么点击Increment按钮时数量应该增加1 场景: 动态显示功能 假如点击Display Message按钮下方动态显示一条数据 （2）编写代码实现剧本操作逻辑和预期结果\nconst { BeforeAll, AfterAll } = require(\"cucumber\"); const { Given, When, Then } = require(\"cucumber\"); const puppeteer = require(\"puppeteer-core\"); const findChrome = require(\"carlo/lib/find_chrome\"); const assert = require(\"assert\"); const fs = require(\"fs\"); let browser = null; let page = null; BeforeAll(async function () { let findChromePath = await findChrome({}); let executablePath = findChromePath.executablePath; browser = await puppeteer.launch({ executablePath, headless: false, slowMo: 200 }); page = await browser.newPage(); }); AfterAll(async function () { await page.close(); await browser.close(); }); Then(/^打开网页，页面应该有标题显示$/, async function () { await page.goto(\"file:///D:/cassie_project/pick-data/cucu_test.html\"); const pngdata = await page.screenshot({ encoding: \"base64\" }); this.attach(pngdata, \"image/png\"); const headlines = await page.$$(\"h1\"); assert.equal(headlines.length, 1); }); Given(/^初始数量应该为(\\d+)$/, async function (n) { const count = await page.$eval('[data-test=\"count-output\"]', (e) =\u003e parseInt(e.innerHTML) ); const pngdata = await page.screenshot({ encoding: \"base64\" }); this.attach(pngdata, \"image/png\"); assert.equal(count, n); }); Then(/^点击Increment按钮时数量应该增加(\\d+)$/, async function (arg1) { const incrementBtn = await page.$('[data-test=\"button-increment\"]'); const initialCount = await page.$eval('[data-test=\"count-output\"]', (e) =\u003e parseInt(e.innerHTML) ); const expectedCount = initialCount + 1; await incrementBtn.click(); const newCount = await page.$eval('[data-test=\"count-output\"]', (e) =\u003e parseInt(e.innerHTML) ); const pngdata = await page.screenshot({ encoding: \"base64\" }); this.attach(pngdata, \"image/png\"); assert.equal(newCount, expectedCount); }); Given(/^点击Display Message按钮下方动态显示一条数据$/, async function () { await page.goto(\"file:///D:/cassie_project/pick-data/cucu_test.html\"); await page.$eval('[data-test=\"button-display\"]', (e) =\u003e e.click()); const pngdata = await page.screenshot({ encoding: \"base64\" }); this.attach(pngdata, \"image/png\"); const displays = await page.$$('[data-test=\"display\"]'); assert.equal(displays.length, 1); }); （3）执行结果，分别为用例执行正确和用例执行错误的情况。（更详细的内容，更方便的操作，可以使用cukeTest配合）\n","description":"","tags":null,"title":"Puppeteer","uri":"/articles/puppeteer/"},{"categories":["articles"],"content":" 前端源码安全 精简和压缩，也可以达到混淆的效果，有效降低代码可读性 （1）编译完的代码删除代码注释，避免注释暴露部分业务内容或代码结构 （2）删除无意义或者多余的空白，删除缩进，缩短变量名等 （3）实现方式：uglify、compressor 2、不可调试，webpack的sourceMap设置为false 3、专门的加密进行混淆，不常用 文件上传 限制文件上传的后缀和文件类型 XSS攻击 对于前端输入的文本进行encode 对于富文本设置白名单，对不在白名单的内容进行过滤，例如\u003cscript\u003e等 对于innerHTML的使用保持敏感，确保输出内容可信任 对于敏感的cookie，仅允服务器通过set-cookie设置，不允许浏览器写入（使用HttpOnly） CSRF攻击 1、设置X-Frame-Options，防止iframe内嵌劫持  ","description":"","tags":null,"title":"前端安全","uri":"/articles/frontend1/"},{"categories":["articles"],"content":"产品建设前期用户体验相关工作总结 （一）产品分析阶段 产品分析阶段需要确定产品的背景、产品的定位、产品的主次，发现本产品与其他产品的差异性，确定技术可实现性，发现风险点： 1、分析用户需求，用户表达的需求不一定真的是用户的痛点，需要结合自己对产品、对行业的认知，分析用户需求产生的深层次原因； 2、分析同类产品的设计和重点，确定我们的产品和其他产品的共同点和不同点； 3、分析产品亮点，这既是产品营销方向，也是后续产品功能的基石； 4、明确系统的使用者，“谁才是真正的用户”决定了产品的方向，需要尽快确定下来； 5、确定团队是否具备技术实现能力； 6、确定支持的展示端（PC、手机端H5，小程序、APP等） （二）原型分析阶段 根据前期产品的调研和规划，进行原型分析，需重点关注以下几点： 1、产品各页面功能的划分； 2、主体区域和侧边栏区域的设计； 3、导航栏的设计； 4、根据产品定位，确定各模块所占区域大小和位置，确定主次关系； 5、分析用户行为，确定用户每个需求需要跳转多少次页面、点击多少按钮，思考哪些能够减少层级结构，哪些可以建立快捷操作； 6、分清功能的主次，来确定各入口的位置，页面的层级等； 7、关键操作、用户常用场景需要设计的简单便捷（登录、搜索、缴费等）； 8、明确系统里存在的角色，各角色上需要做哪些差异处理，最好的设计是与本用户无关的信息不做展示； 9、根据功能相关性，确定功能应该在哪些页面出现，尽量不要出现相关功能在不同的页面或者各种功能都糅杂在一个页面的情况； 10、用户当前需要关注的内容，建议设计在页面显眼位置，并增加快捷操作（比如老年大学中用户当前正在进行的课程，待缴费的课程等在首页可查看）； 11、分析用户行为，设计和展示内容要符合用户预期，不能违背常理； （三）UI设计阶段 根据原型和产品分析，确定UI设计，需要关注以下几点： 1、UI设计规范，需要制定包括windows字体、mac字体、字号、间隔设计、主色调、色彩组合、按钮、单选框、多选框、翻页等组件的规范； 2、根据产品定位确定是否需要提供响应式设计，需要支持的屏幕尺寸范围等； 3、考虑loading状态的设计； 4、考虑各类空数据的展示效果； 5、考虑各类异常状态的设计； 6、考虑设计可扩展性，包括文本长短、分类多少、数据多少、选择项多少等对页面的影响； 7、提示信息需要精准、简洁； 8、设计点击事件、hover事件、滚动事件等，能让用户用最方便的方式看到最关键的信息； 9、可操作区域一定要符合使用习惯，不能出现可以滚动区域用户不知道可以滚动，可以操作的而区域，用户不知道可以操作的设计； （四）前端实现阶段 前端开发在高保真还原设计图的基础上，需要考虑一些非功能设计，包括： 1、用户访问地址是否合理，是否会暴露关键信息； 2、用户非预期操作下的页面效果； 3、用户刷新、回退的情况下的状态记录； 4、用户必输项校验和规定，一些特定的要求必须要有提示； 5、用户错误输入或错误操作需要有提示； 6、用户操作反馈要注意及时和准确 7、关键操作需要考虑增加用户确认操作； 8、确定各输入框的长短、字符类型限制； 9、考虑对用户输入做暂存处理，特别是输入较多的情况，考虑本地存储用户输入（比如wiki的文章编辑）； 10、vue导航模式选择hash还是history模式（http://edu.test.com/home或 http://edu.test.com/#home）； 11、翻页操作进入下一级页面后回退或者返回操作，是否能回退到跳转前的页面； 12、回退或返回上一级页面，是否需要支持记录上一级页面的滚动位置、上一级页面的状态； 13、在需要用户等待的地方通过loading或者提示等让用户知道等待是合理的，不是系统问题； 14、用户可点击区域需要修改鼠标状态； 15、增加对css3动画的应用，增加切换动画，能够使整个系统更流畅，用户使用感也会更好； 16、首屏时间的控制，尽量控制在3s内，越短越好，有较长需要等待的地方做提示；\n","description":"","tags":null,"title":"产品建设前期用户体验相关工作总结","uri":"/articles/userexperience/"},{"categories":["articles"],"content":"这篇文章起源于一个工作中遇到的需求，虽然后面因为下载文件的总体积过大而没有选择这个方案，但是这个内容还是非常值得分享一下的。值得一提的是，JSZip的原理是将文件都下载到内存中，然后调用JSZip统一打包，然后触发保存，所以总的文件越大，性能越差，经过测试，1G以下的文件对性能影响较小，几个G的也能够处理，只是比较缓慢。所以，选用这个方案，建议总文件大小小于1G。 对于此需求，设计了如下demo：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"./js/jszip.js\"\u003e\u003c/script\u003e \u003cscript src=\"./js/FileSaver.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"download\"\u003e下载并压缩\u003c/button\u003e \u003c/body\u003e \u003cscript\u003e window.onload = function() { const fileAjax = (url, callback) =\u003e { console.log(url) const xhr = new XMLHttpRequest() xhr.open('get', url, true) xhr.responseType = 'blob' xhr.onreadystatechange = function () { if (xhr.readyState === 4 \u0026\u0026 xhr.status === 200) { callback(xhr.response) } } xhr.send() } const download = (urls) =\u003e { const zip = new JSZip() const folder = zip.folder('personInfomation') let curIndex = 0 const downCallback = () =\u003e { fileAjax(urls[curIndex].url, (blob) =\u003e { folder.file(urls[curIndex].filename, blob) curIndex +=1 if (curIndex \u003c urls.length - 1) { downCallback() } else { zip.generateAsync({ type: 'blob'}) .then((content) =\u003e { saveAs(content, 'test.zip') }) } }) } downCallback() } const urls = [ { filename: 'test1.png', url: 'https://www.test.com/1.png' }, { filename: 'test2.png', url: 'https://www.test.com/2.png' } ] const btn = document.querySelector('#download') btn.addEventListener('click', () =\u003e { download(urls) }) } \u003c/script\u003e \u003c/html\u003e 实现的主要逻辑是，获取到文件名和下载地址后，循环的发起http请求，当一个请求完成后，将文件存放在zip文件内（此时zip还在内存区），然后再调起下一个http请求，知道文件全部下载完成。最后将内存区的zip文件保存到本地。 当然，要让这个方案更加完善，还可以使用promise和axios模拟多线程并发请求，同时考虑文件下载失败后重新发起请求等多种场景，这里为了讲目光集中在JSZip，就不再扩展开讲了。 JSZip的使用范围不止于此，它还可以运行在node环境，可以通过fileReader读取本地文件，然后进行压缩。因此，如果前端项目需要将文件打包为zip压缩包，可以在编译命令“npm run build”里面加上压缩的操作，不再使用手动压缩的方式。实现方式如下： 读取文件夹下的文件 如果是文件夹就用jszip创建文件夹，然后递归的执行readDir方法 如果是文件就读取文件，jszip创建文件 将内存区的jszip文件压缩 删除旧的zip包，将新的压缩包写入指定路径\nconst JSZip = require('jszip') const fs = require('fs') const path = require('path') const readDir = (filePath, directory) =\u003e { const files = fs.readdirSync(filePath) files.forEach((fileName) =\u003e { const fileDir = path.join(filePath, fileName) const stats = fs.statSync(fileDir) if (stats.isFile()) { const content = fs.readFileSync(fileDir, 'utf8') directory.file(fileName, content) } else if (stats.isDirectory()) { const directory = jszip.folder(fileName) readDir(fileDir, directory) } }) } const jszip = new JSZip() const filePath = path.resolve('./cbkc-web') readDir(filePath, jszip) jszip .generateAsync({ type: 'nodeBuffer', compression: 'DEFLATE', compressionOptions: { level: 9, }, }) .then((content) =\u003e { fs.unlinkSync('./cbkc-web.zip') fs.writeFileSync('./cbkc-web.zip', content) }) 另一方面，JSZip还可以解压缩zip文件。在游戏开发中，尤其是小游戏平台，比如之前比较火热的h5小游戏，平台能够提供给游戏的包体积非常有限，这样的情况下，小游戏开发者不得不把资源压缩后存放在客户端，然后通过启动时读取文件后解压缩，这个时候就可以用到JSZip了。\n","description":"","tags":null,"title":"前端压缩之JSZip","uri":"/articles/jszip/"},{"categories":["articles"],"content":"前端模块化设计不仅是组件的设计，更是整个前端项目的模块化，在项目开发中，需要从以下几个方面考虑。\n 图片资源管理，包括字体图标、雪碧图、图片转base64、图片单独引入等。 css资源管理，例如将公用的css写到commom.css里面，根据项目UI设计标准编写可复用的基础样式等。 api进行封装，统一处理请求头、处理请求响应、进行错误处理，同时将所有接口按业务逻辑分为多个文件，分模块管理。 utils文件夹存放公用函数。 项目中涉及的常量、各种key、value的映射关系，统一在constant文件夹下进行管理。 封装组件，将具有相似功能，相似设计的模块封装为组件。 封装filter，例如将接口传递的时间在组件渲染为UI要求的格式。 封装mixin，例如每个用到Page组件的页面都包括翻页相关的data、method，就可以封装一个mixin。 合理的划分界面模块，每个模块大小不应该超过500行代码。 routes统一在router文件夹下进行配置管理。 vuex中的modules支持模块化设计。 配置与应用分离，应用相关的对外的配置，存放在config文件夹下。  ","description":"","tags":null,"title":"前端模块化设计","uri":"/articles/frontend2/"}]
